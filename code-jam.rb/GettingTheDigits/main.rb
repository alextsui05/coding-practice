#!/usr/bin/env ruby
# Recover the phone number from a scrambled string generated by some jerk of a
# friend.
#
# According to the problem statement, a friend has a phone number that they
# write out in uppercase letters with no spaces, and then shuffles the string.
# A unique phone number can be recovered from an input string.
#
# The approach is by binning the characters of the string, then extracting
# digits by whether it is possible to spell them with the remaining characters.
# There is a possibility of getting stuck without using all the characters, so
# we extract the digits by order of least-used letter (i.e. zero for the z).
#
# The complexity of the algorithm is bounded by the number of digits we have to
# extract, and the longest possible phone number is ~600 for the large
# example. At most this many digits will be extracted from a loop through the
# candidate digits, which is at most length-5 string. In the worst case, we have
# to make 3000 comparisons. Let's say it is linear in the length of the input
# string.
#
# Problem: https://code.google.com/codejam/contest/11254486/dashboard#s=p0&a=0
# Analysis: https://code.google.com/codejam/contest/11254486/dashboard#s=a&a=0

if __FILE__ == $0
    # ARGF receives the contents of stdin
    n = ARGF.readline.to_i
    0.upto(n-1) do |test_case|
        s = ARGF.readline

        # We can do a little computation before value interpolation
        print "Case ##{test_case + 1}: "

        # chomp removes the trailing newline from the input string
        #
        # Hash.new(0) creates an empty hash where if a key does not exist, it
        # gives a default value of 0. By default, the default value is nil.
        #
        # each_with_object is cleaner than reduce in this case because the body
        # does not have to return the object
        buckets = s.chomp.each_char.each_with_object(Hash.new(0)) { |val, obj| obj[val] += 1 }
        digits = []
        digit_vals = [0, 6, 8, 2, 4, 5, 7, 3, 9, 1]
        ["ZERO", "SIX", "EIGHT", "TWO", "FOUR", "FIVE", "SEVEN", "THREE", "NINE", "ONE"]
        .map { |s| s.each_char.each_with_object(Hash.new(0)) { |val, obj| obj[val] += 1 } }
        .each_with_index { |val, i|
            res = true

            # In ruby, a do-while loop looks like this
            loop do
                res = val.reduce(res) { |init, entry|
                    init &= (buckets[entry[0]] >= entry[1])
                }
                if res then
                    val.each { |entry| buckets[entry[0]] -= entry[1] }
                    digits.push digit_vals[i]
                end
                break if !res
            end
        }
        puts digits.sort.map { |x| x.to_s }.reduce('', :+)
    end
end
